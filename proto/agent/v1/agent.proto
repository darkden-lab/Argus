syntax = "proto3";

package agent.v1;

option go_package = "github.com/k8s-dashboard/backend/pkg/agentpb;agentpb";

import "google/protobuf/timestamp.proto";

// ClusterAgent is the gRPC service that agents connect to on the dashboard backend.
service ClusterAgent {
  // Register is called once by the agent on first connection to exchange
  // a one-time registration token for permanent credentials.
  rpc Register(RegisterRequest) returns (RegisterResponse);

  // Stream is a long-lived bidirectional stream between dashboard and agent.
  // The dashboard sends requests (K8s API calls, watch subscriptions, pings)
  // and the agent sends back responses, watch events, and pongs.
  rpc Stream(stream AgentMessage) returns (stream DashboardMessage);
}

// ---------- Registration ----------

message RegisterRequest {
  // One-time JWT registration token generated by the dashboard.
  string token = 1;
  // Human-readable name chosen by the user for this cluster.
  string cluster_name = 2;
  // Information about the cluster collected by the agent at startup.
  ClusterInfo cluster_info = 3;
}

message RegisterResponse {
  // Unique cluster ID assigned by the dashboard (UUID).
  string cluster_id = 1;
  // Permanent agent credential (long-lived JWT) for future Stream calls.
  string agent_token = 2;
}

// ---------- Bidirectional Stream Messages ----------

// AgentMessage is sent from the agent to the dashboard.
message AgentMessage {
  oneof payload {
    K8sResponse k8s_response = 1;
    WatchEvent watch_event = 2;
    Pong pong = 3;
    ClusterInfo cluster_info = 4;
  }
}

// DashboardMessage is sent from the dashboard to the agent.
message DashboardMessage {
  oneof payload {
    K8sRequest k8s_request = 1;
    WatchSubscribe watch_subscribe = 2;
    WatchUnsubscribe watch_unsubscribe = 3;
    Ping ping = 4;
  }
}

// ---------- Kubernetes API Proxy ----------

message K8sRequest {
  // Unique request ID to correlate with the response.
  string request_id = 1;
  // HTTP method: GET, POST, PUT, PATCH, DELETE.
  string method = 2;
  // Kubernetes API path, e.g. /api/v1/namespaces/default/pods.
  string path = 3;
  // Optional request body (JSON).
  bytes body = 4;
  // Optional HTTP headers to forward.
  map<string, string> headers = 5;
  // Optional query parameters.
  map<string, string> query_params = 6;
}

message K8sResponse {
  // Matches K8sRequest.request_id.
  string request_id = 1;
  // HTTP status code from the Kubernetes API.
  int32 status_code = 2;
  // Response body (JSON).
  bytes body = 3;
  // Response headers.
  map<string, string> headers = 4;
  // Error message if the request could not be executed locally.
  string error = 5;
}

// ---------- Watch ----------

message WatchSubscribe {
  // Unique watch ID.
  string watch_id = 1;
  // Kubernetes API path for the watch, e.g. /api/v1/namespaces/default/pods.
  string path = 2;
  // Resource version to start watching from (empty = from now).
  string resource_version = 3;
}

message WatchUnsubscribe {
  string watch_id = 1;
}

message WatchEvent {
  // ID of the watch this event belongs to.
  string watch_id = 1;
  // Event type: ADDED, MODIFIED, DELETED, ERROR.
  string event_type = 2;
  // The Kubernetes object as JSON.
  bytes object = 3;
}

// ---------- Heartbeat ----------

message Ping {
  google.protobuf.Timestamp timestamp = 1;
}

message Pong {
  google.protobuf.Timestamp timestamp = 1;
}

// ---------- Cluster Discovery ----------

message ClusterInfo {
  // Kubernetes server version (e.g. "v1.28.3").
  string kubernetes_version = 1;
  // Platform (e.g. "linux/amd64").
  string platform = 2;
  // Number of nodes in the cluster.
  int32 node_count = 3;
  // List of namespace names.
  repeated string namespaces = 4;
  // List of installed CRD names.
  repeated string crds = 5;
  // Agent binary version.
  string agent_version = 6;
}
